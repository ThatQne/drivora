{"ast":null,"code":"var _jsxFileName = \"C:\\\\Users\\\\thato\\\\Downloads\\\\car-app\\\\src\\\\context\\\\AppContext.tsx\",\n  _s = $RefreshSig$(),\n  _s2 = $RefreshSig$();\nimport React, { createContext, useContext, useReducer, useEffect, useState, useMemo, useCallback } from 'react';\nimport { AuthService } from '../services/authService.ts';\nimport ApiService from '../services/apiService.ts';\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nconst initialState = {\n  currentUser: null,\n  vehicles: [],\n  listings: [],\n  allListings: [],\n  auctions: [],\n  trades: [],\n  messages: [],\n  conversations: [],\n  reviews: [],\n  sales: [],\n  users: [],\n  isAuthenticated: false,\n  loading: false,\n  error: null\n};\nfunction appReducer(state, action) {\n  switch (action.type) {\n    case 'SET_USER':\n      return {\n        ...state,\n        currentUser: action.payload,\n        isAuthenticated: action.payload !== null\n      };\n    case 'SET_CURRENT_USER':\n      return {\n        ...state,\n        currentUser: action.payload,\n        isAuthenticated: true\n      };\n    case 'LOGOUT':\n      return {\n        ...initialState,\n        // Reset to initial state\n        isAuthenticated: false\n      };\n    case 'SET_LOADING':\n      return {\n        ...state,\n        loading: action.payload\n      };\n    case 'SET_ERROR':\n      return {\n        ...state,\n        error: action.payload\n      };\n    case 'SET_VEHICLES':\n      return {\n        ...state,\n        vehicles: action.payload\n      };\n    case 'ADD_VEHICLE':\n      return {\n        ...state,\n        vehicles: [...state.vehicles, action.payload]\n      };\n    case 'UPDATE_VEHICLE':\n      return {\n        ...state,\n        vehicles: state.vehicles.map(v => v.id === action.payload.id ? action.payload : v)\n      };\n    case 'DELETE_VEHICLE':\n      return {\n        ...state,\n        vehicles: state.vehicles.filter(v => v.id !== action.payload)\n      };\n    case 'SET_LISTINGS':\n      return {\n        ...state,\n        listings: action.payload\n      };\n    case 'ADD_LISTING':\n      return {\n        ...state,\n        listings: [...state.listings, action.payload]\n      };\n    case 'UPDATE_LISTING':\n      return {\n        ...state,\n        listings: state.listings.map(l => l.id === action.payload.id ? action.payload : l)\n      };\n    case 'DELETE_LISTING':\n      return {\n        ...state,\n        listings: state.listings.filter(l => l.id !== action.payload)\n      };\n    case 'SET_TRADES':\n      return {\n        ...state,\n        trades: action.payload\n      };\n    case 'ADD_TRADE':\n      return {\n        ...state,\n        trades: [...state.trades, action.payload]\n      };\n    case 'UPDATE_TRADE':\n      return {\n        ...state,\n        trades: state.trades.map(t => t.id === action.payload.id ? action.payload : t)\n      };\n    case 'SET_MESSAGES':\n      return {\n        ...state,\n        messages: action.payload\n      };\n    case 'ADD_MESSAGE':\n      return {\n        ...state,\n        messages: [...state.messages, action.payload]\n      };\n    case 'SET_CONVERSATIONS':\n      console.log('📞 Setting conversations in state:', action.payload.length, 'conversations');\n      console.log('📞 Sample conversations:', action.payload.slice(0, 2).map(c => ({\n        id: c.id,\n        participants: c.participants,\n        otherUser: c.otherUser ? {\n          id: c.otherUser.id,\n          username: c.otherUser.username\n        } : null\n      })));\n      return {\n        ...state,\n        conversations: action.payload\n      };\n    case 'SET_REVIEWS':\n      return {\n        ...state,\n        reviews: action.payload\n      };\n    case 'SET_USERS':\n      return {\n        ...state,\n        users: action.payload\n      };\n    case 'SET_ALL_LISTINGS':\n      return {\n        ...state,\n        allListings: action.payload\n      };\n    default:\n      return state;\n  }\n}\nconst AppContext = /*#__PURE__*/createContext(undefined);\nexport function AppProvider({\n  children\n}) {\n  _s();\n  const [state, dispatch] = useReducer(appReducer, initialState);\n  const [activeTab, setActiveTab] = React.useState('garage');\n  const [listingsCache, setListingsCache] = useState({\n    data: [],\n    timestamp: 0,\n    ttl: 30000\n  }); // 30 second cache\n\n  // Add loading states to prevent duplicate calls\n  const [loadingStates, setLoadingStates] = useState({\n    userData: false,\n    users: false,\n    listings: false,\n    messages: false\n  });\n\n  // Add messages cache\n  const [messagesCache, setMessagesCache] = useState({\n    messages: [],\n    conversations: [],\n    timestamp: 0,\n    ttl: 60000\n  }); // 1 minute cache\n\n  useEffect(() => {\n    // Initialize app state by checking API authentication\n    const initializeAuth = async () => {\n      try {\n        // Only check if there's a token present\n        const token = localStorage.getItem('carTrade_token');\n        if (!token) {\n          return;\n        }\n        const authCheck = await ApiService.verifyToken();\n        if (authCheck.valid && authCheck.user) {\n          const user = {\n            ...authCheck.user,\n            id: authCheck.user._id || authCheck.user.id\n          };\n          dispatch({\n            type: 'SET_CURRENT_USER',\n            payload: user\n          });\n          await loadUserData(user.id);\n        } else {\n          ApiService.logout();\n          AuthService.logout();\n        }\n      } catch (error) {\n        // Clear any stale tokens on error\n        ApiService.logout();\n        AuthService.logout();\n        dispatch({\n          type: 'LOGOUT'\n        });\n      }\n    };\n    initializeAuth();\n    // DON'T load all users on startup - load them when needed\n  }, []);\n  const loadUserData = async userId => {\n    // Prevent duplicate calls\n    if (loadingStates.userData) {\n      console.log('⏳ User data already loading, skipping duplicate call');\n      return;\n    }\n    setLoadingStates(prev => ({\n      ...prev,\n      userData: true\n    }));\n    try {\n      const [vehicles, listings, trades] = await Promise.all([ApiService.getUserVehicles(), ApiService.getUserListings(), ApiService.getUserTrades()]);\n      console.log('📊 Loaded trades from API:', trades.length);\n\n      // Convert MongoDB _id to id for frontend compatibility\n      const vehiclesWithId = vehicles.map(v => ({\n        ...v,\n        id: v._id || v.id\n      }));\n      const listingsWithId = listings.map(l => ({\n        ...l,\n        id: l._id || l.id\n      }));\n      // Extract users from populated trade objects\n      const usersFromTrades = [];\n      const userIds = new Set();\n      const tradesWithId = trades.map(t => {\n        const trade = {\n          ...t,\n          id: t._id || t.id\n        };\n\n        // Handle populated vehicle arrays - preserve vehicle data for display\n        // but also create ID arrays for consistency\n        if (trade.offererVehicleIds && Array.isArray(trade.offererVehicleIds)) {\n          // Store the populated vehicle objects for later reference\n          trade.offererVehicleObjects = trade.offererVehicleIds.filter(v => typeof v === 'object' && v.make).map(v => ({\n            ...v,\n            id: v._id || v.id\n          }));\n\n          // Convert to IDs for consistency\n          trade.offererVehicleIds = trade.offererVehicleIds.map(v => typeof v === 'object' ? v._id || v.id : v);\n        }\n        if (trade.receiverVehicleIds && Array.isArray(trade.receiverVehicleIds)) {\n          // Store the populated vehicle objects for later reference\n          trade.receiverVehicleObjects = trade.receiverVehicleIds.filter(v => typeof v === 'object' && v.make).map(v => ({\n            ...v,\n            id: v._id || v.id\n          }));\n\n          // Convert to IDs for consistency\n          trade.receiverVehicleIds = trade.receiverVehicleIds.map(v => typeof v === 'object' ? v._id || v.id : v);\n        }\n\n        // Handle populated user objects - extract user data before converting to IDs\n        if (trade.offererUserId && typeof trade.offererUserId === 'object') {\n          const offererUser = {\n            ...trade.offererUserId,\n            id: trade.offererUserId._id || trade.offererUserId.id\n          };\n          usersFromTrades.push(offererUser);\n          userIds.add(offererUser.id);\n          trade.offererUserId = offererUser.id;\n        } else if (typeof trade.offererUserId === 'string') {\n          userIds.add(trade.offererUserId);\n        }\n        if (trade.receiverUserId && typeof trade.receiverUserId === 'object') {\n          const receiverUser = {\n            ...trade.receiverUserId,\n            id: trade.receiverUserId._id || trade.receiverUserId.id\n          };\n          usersFromTrades.push(receiverUser);\n          userIds.add(receiverUser.id);\n          trade.receiverUserId = receiverUser.id;\n        } else if (typeof trade.receiverUserId === 'string') {\n          userIds.add(trade.receiverUserId);\n        }\n\n        // Handle populated listing object\n        if (trade.listingId && typeof trade.listingId === 'object') {\n          trade.listingId = trade.listingId._id || trade.listingId.id;\n        }\n        return trade;\n      });\n      dispatch({\n        type: 'SET_VEHICLES',\n        payload: vehiclesWithId\n      });\n      dispatch({\n        type: 'SET_LISTINGS',\n        payload: listingsWithId\n      });\n      dispatch({\n        type: 'SET_TRADES',\n        payload: tradesWithId\n      });\n      console.log('👥 Extracted users from initial trades:', usersFromTrades.map(u => ({\n        id: u.id,\n        username: u.username\n      })));\n\n      // Add extracted users to state\n      let allUsers = [...state.users];\n      usersFromTrades.forEach(user => {\n        if (!allUsers.find(u => u.id === user.id)) {\n          allUsers.push(user);\n        }\n      });\n\n      // Find users that still need to be fetched\n      const missingUserIds = Array.from(userIds).filter(id => !allUsers.find(u => u.id === id));\n      if (missingUserIds.length > 0) {\n        try {\n          console.log('🔍 Loading missing initial trade users via batch API...');\n          const users = await ApiService.getUsersBatch(missingUserIds);\n          console.log('✅ Loaded missing initial trade users:', users.map(u => ({\n            id: u.id,\n            username: u.username\n          })));\n\n          // Add fetched users to existing users\n          users.forEach(user => {\n            if (!allUsers.find(u => u.id === user.id)) {\n              allUsers.push(user);\n            }\n          });\n        } catch (error) {\n          console.error('❌ Error loading missing initial trade users:', error);\n        }\n      }\n      dispatch({\n        type: 'SET_USERS',\n        payload: allUsers\n      });\n\n      // Load messages and associated users separately\n      await loadUserMessages();\n    } catch (error) {\n      console.error('Error loading user data:', error);\n    } finally {\n      setLoadingStates(prev => ({\n        ...prev,\n        userData: false\n      }));\n    }\n  };\n\n  // Add a function to force reload trades specifically\n  const reloadTrades = async () => {\n    try {\n      console.log('🔄 Force reloading trades...');\n      const trades = await ApiService.getUserTrades();\n      console.log('📊 Reloaded trades from API:', trades.length);\n\n      // Extract users from populated trade objects\n      const usersFromTrades = [];\n      const userIds = new Set();\n      const tradesWithId = trades.map(t => {\n        const trade = {\n          ...t,\n          id: t._id || t.id\n        };\n\n        // Handle populated vehicle arrays - preserve vehicle data for display\n        // but also create ID arrays for consistency\n        if (trade.offererVehicleIds && Array.isArray(trade.offererVehicleIds)) {\n          // Store the populated vehicle objects for later reference\n          trade.offererVehicleObjects = trade.offererVehicleIds.filter(v => typeof v === 'object' && v.make).map(v => ({\n            ...v,\n            id: v._id || v.id\n          }));\n\n          // Convert to IDs for consistency\n          trade.offererVehicleIds = trade.offererVehicleIds.map(v => typeof v === 'object' ? v._id || v.id : v);\n        }\n        if (trade.receiverVehicleIds && Array.isArray(trade.receiverVehicleIds)) {\n          // Store the populated vehicle objects for later reference\n          trade.receiverVehicleObjects = trade.receiverVehicleIds.filter(v => typeof v === 'object' && v.make).map(v => ({\n            ...v,\n            id: v._id || v.id\n          }));\n\n          // Convert to IDs for consistency\n          trade.receiverVehicleIds = trade.receiverVehicleIds.map(v => typeof v === 'object' ? v._id || v.id : v);\n        }\n\n        // Handle populated user objects - extract user data before converting to IDs\n        if (trade.offererUserId && typeof trade.offererUserId === 'object') {\n          const offererUser = {\n            ...trade.offererUserId,\n            id: trade.offererUserId._id || trade.offererUserId.id\n          };\n          usersFromTrades.push(offererUser);\n          userIds.add(offererUser.id);\n          trade.offererUserId = offererUser.id;\n        } else if (typeof trade.offererUserId === 'string') {\n          userIds.add(trade.offererUserId);\n        }\n        if (trade.receiverUserId && typeof trade.receiverUserId === 'object') {\n          const receiverUser = {\n            ...trade.receiverUserId,\n            id: trade.receiverUserId._id || trade.receiverUserId.id\n          };\n          usersFromTrades.push(receiverUser);\n          userIds.add(receiverUser.id);\n          trade.receiverUserId = receiverUser.id;\n        } else if (typeof trade.receiverUserId === 'string') {\n          userIds.add(trade.receiverUserId);\n        }\n\n        // Handle populated listing object\n        if (trade.listingId && typeof trade.listingId === 'object') {\n          trade.listingId = trade.listingId._id || trade.listingId.id;\n        }\n        return trade;\n      });\n      console.log('👥 Extracted users from trades:', usersFromTrades.map(u => ({\n        id: u.id,\n        username: u.username\n      })));\n      console.log('👥 All user IDs needed for trades:', Array.from(userIds));\n\n      // Update trades first\n      dispatch({\n        type: 'SET_TRADES',\n        payload: tradesWithId\n      });\n\n      // Add extracted users to state\n      let allUsers = [...state.users];\n      usersFromTrades.forEach(user => {\n        if (!allUsers.find(u => u.id === user.id)) {\n          allUsers.push(user);\n        }\n      });\n\n      // Find users that still need to be fetched\n      const missingUserIds = Array.from(userIds).filter(id => !allUsers.find(u => u.id === id));\n      console.log('❓ Missing user IDs after adding populated users:', missingUserIds);\n      if (missingUserIds.length > 0) {\n        try {\n          console.log('🔍 Loading missing trade users via batch API...');\n          const users = await ApiService.getUsersBatch(missingUserIds);\n          console.log('✅ Loaded missing trade users:', users.map(u => ({\n            id: u.id,\n            username: u.username\n          })));\n\n          // Add fetched users to existing users\n          users.forEach(user => {\n            if (!allUsers.find(u => u.id === user.id)) {\n              allUsers.push(user);\n            }\n          });\n        } catch (error) {\n          console.error('❌ Error loading missing trade users:', error);\n        }\n      }\n      console.log('👥 Final users state after trade reload:', allUsers.map(u => ({\n        id: u.id,\n        username: u.username\n      })));\n      dispatch({\n        type: 'SET_USERS',\n        payload: allUsers\n      });\n    } catch (error) {\n      console.error('Error reloading trades:', error);\n    }\n  };\n  const loadAllUsers = async () => {\n    // Prevent duplicate calls\n    if (loadingStates.users) {\n      console.log('⏳ Users already loading, skipping duplicate call');\n      return;\n    }\n    setLoadingStates(prev => ({\n      ...prev,\n      users: true\n    }));\n    try {\n      const users = await ApiService.getAllUsers();\n      const usersWithId = users.map(u => ({\n        ...u,\n        id: u._id || u.id\n      }));\n      dispatch({\n        type: 'SET_USERS',\n        payload: usersWithId\n      });\n    } catch (error) {\n      console.error('Error loading users:', error);\n      // Fallback to empty array if API fails\n      dispatch({\n        type: 'SET_USERS',\n        payload: []\n      });\n    } finally {\n      setLoadingStates(prev => ({\n        ...prev,\n        users: false\n      }));\n    }\n  };\n\n  // Lazy load specific users when needed\n  const loadUsersIfNeeded = useCallback(async userIds => {\n    const missingUserIds = userIds.filter(id => !state.users.find(u => u.id === id));\n    if (missingUserIds.length === 0) {\n      return; // All users already loaded\n    }\n\n    // Prevent duplicate calls\n    if (loadingStates.users) {\n      return;\n    }\n    setLoadingStates(prev => ({\n      ...prev,\n      users: true\n    }));\n    try {\n      // Use efficient batch endpoint for specific users\n      const users = await ApiService.getUsersBatch(missingUserIds);\n      const usersWithId = users.map(u => ({\n        ...u,\n        id: u._id || u.id\n      }));\n\n      // Merge with existing users\n      const updatedUsers = [...state.users, ...usersWithId];\n      dispatch({\n        type: 'SET_USERS',\n        payload: updatedUsers\n      });\n    } catch (error) {\n      console.error('Error loading users batch:', error);\n      // Fallback to loading all users if batch fails\n      if (state.users.length === 0) {\n        await loadAllUsers();\n      }\n    } finally {\n      setLoadingStates(prev => ({\n        ...prev,\n        users: false\n      }));\n    }\n  }, [state.users, loadingStates.users]);\n\n  // Memoize callback functions to prevent unnecessary re-renders\n  const loadAllListings = useCallback(async (forceRefresh = false) => {\n    // Prevent duplicate calls\n    if (loadingStates.listings && !forceRefresh) {\n      return;\n    }\n    setLoadingStates(prev => ({\n      ...prev,\n      listings: true\n    }));\n    try {\n      // Check cache first (unless force refresh)\n      const now = Date.now();\n      if (!forceRefresh && listingsCache.data.length > 0 && now - listingsCache.timestamp < listingsCache.ttl) {\n        dispatch({\n          type: 'SET_ALL_LISTINGS',\n          payload: listingsCache.data\n        });\n        return;\n      }\n\n      // Load all public listings from the API\n      const response = await ApiService.getAllListings();\n\n      // Optimize data processing - avoid complex operations in map\n      const listingsWithId = response.listings.map(l => {\n        // Simple ID conversion only\n        const listing = {\n          ...l,\n          id: l._id || l.id,\n          vehicleId: l.vehicleId,\n          sellerId: l.sellerId\n        };\n\n        // Add populated data if it exists from backend aggregation\n        if (l.vehicle && typeof l.vehicle === 'object' && l.vehicle._id) {\n          listing.vehicle = {\n            ...l.vehicle,\n            id: l.vehicle._id || l.vehicle.id\n          };\n        }\n        if (l.seller && typeof l.seller === 'object' && l.seller._id) {\n          listing.seller = {\n            ...l.seller,\n            id: l.seller._id || l.seller.id\n          };\n        }\n        return listing;\n      });\n\n      // Extract unique seller IDs that need to be loaded\n      const sellerIds = [...new Set(listingsWithId.map(l => l.sellerId))];\n\n      // Only load users if we don't have them yet\n      await loadUsersIfNeeded(sellerIds);\n\n      // Update cache\n      setListingsCache({\n        data: listingsWithId,\n        timestamp: now,\n        ttl: 30000\n      });\n      dispatch({\n        type: 'SET_ALL_LISTINGS',\n        payload: listingsWithId\n      });\n    } catch (error) {\n      console.error('Error loading all listings:', error);\n      // Fallback to empty array if API fails\n      dispatch({\n        type: 'SET_ALL_LISTINGS',\n        payload: []\n      });\n    } finally {\n      setLoadingStates(prev => ({\n        ...prev,\n        listings: false\n      }));\n    }\n  }, [listingsCache.data, listingsCache.timestamp, listingsCache.ttl, loadUsersIfNeeded, loadingStates.listings]);\n\n  // Memoize other frequently used functions\n  const login = useCallback(async (username, password, rememberMe = false) => {\n    try {\n      const response = await ApiService.login(username, password);\n      // The ApiService.login should automatically store the token\n      const user = {\n        ...response.user,\n        id: response.user._id || response.user.id\n      };\n      dispatch({\n        type: 'SET_CURRENT_USER',\n        payload: user\n      });\n      // Load user data after successful login\n      await loadUserData(user.id);\n      return {\n        success: true\n      };\n    } catch (error) {\n      console.error('Login error:', error);\n      return {\n        success: false,\n        error: error.message || 'Login failed'\n      };\n    }\n  }, []);\n  const logout = useCallback(() => {\n    // Clear both API token and AuthService localStorage data\n    ApiService.logout();\n    AuthService.logout();\n\n    // Clear any additional auth-related localStorage items\n    localStorage.removeItem('carTrade_remember');\n    dispatch({\n      type: 'LOGOUT'\n    });\n    setActiveTab('garage');\n    // Clear cache on logout\n    setListingsCache({\n      data: [],\n      timestamp: 0,\n      ttl: 30000\n    });\n  }, []);\n  const register = useCallback(async userData => {\n    try {\n      const response = await ApiService.register(userData);\n      const user = {\n        ...response.user,\n        id: response.user._id || response.user.id\n      };\n      dispatch({\n        type: 'SET_CURRENT_USER',\n        payload: user\n      });\n      // Load user data after successful registration\n      await loadUserData(user.id);\n      return {\n        success: true\n      };\n    } catch (error) {\n      console.error('Registration error:', error);\n      return {\n        success: false,\n        error: error.message || 'Registration failed'\n      };\n    }\n  }, []);\n  const updateUser = user => {\n    try {\n      AuthService.updateUser(user);\n      dispatch({\n        type: 'SET_USER',\n        payload: user\n      });\n    } catch (error) {\n      console.error('Error in context updateUser:', error);\n      throw error;\n    }\n  };\n  const addVehicle = async vehicleData => {\n    if (!state.currentUser) return;\n    try {\n      const newVehicle = await ApiService.createVehicle(vehicleData);\n\n      // Convert MongoDB _id to id for frontend compatibility\n      const mongoVehicle = newVehicle;\n      const vehicleWithId = {\n        ...newVehicle,\n        id: mongoVehicle._id || newVehicle.id,\n        // Ensure boolean fields have default values\n        isListed: newVehicle.isListed || false,\n        isAuctioned: newVehicle.isAuctioned || false\n      };\n      dispatch({\n        type: 'ADD_VEHICLE',\n        payload: vehicleWithId\n      });\n\n      // Reload user data to ensure everything is in sync\n      if (state.currentUser) {\n        await loadUserData(state.currentUser.id);\n      }\n    } catch (error) {\n      console.error('Error adding vehicle:', error);\n    }\n  };\n  const updateVehicle = async updatedVehicle => {\n    try {\n      const vehicle = await ApiService.updateVehicle(updatedVehicle.id, updatedVehicle);\n      dispatch({\n        type: 'UPDATE_VEHICLE',\n        payload: vehicle\n      });\n\n      // If the vehicle has an active listing, refresh all listings to ensure \n      // the listing shows the updated vehicle images\n      if (vehicle.isListed && vehicle.listingId) {\n        await loadAllListings(true);\n      }\n    } catch (error) {\n      console.error('Error updating vehicle:', error);\n    }\n  };\n  const deleteVehicle = async vehicleId => {\n    try {\n      await ApiService.deleteVehicle(vehicleId);\n      dispatch({\n        type: 'DELETE_VEHICLE',\n        payload: vehicleId\n      });\n    } catch (error) {\n      console.error('Error deleting vehicle:', error);\n    }\n  };\n  const addListing = async listingData => {\n    if (!state.currentUser) return;\n    try {\n      const newListing = await ApiService.createListing(listingData);\n      // Convert MongoDB _id to id for frontend compatibility\n      const mongoListing = newListing;\n      const listingWithId = {\n        ...newListing,\n        id: mongoListing._id || newListing.id\n      };\n      dispatch({\n        type: 'ADD_LISTING',\n        payload: listingWithId\n      });\n\n      // Update vehicle to mark as listed immediately in local state\n      const vehicle = state.vehicles.find(v => v.id === listingData.vehicleId);\n      if (vehicle) {\n        const updatedVehicle = {\n          ...vehicle,\n          isListed: true,\n          listingId: listingWithId.id,\n          updatedAt: new Date().toISOString()\n        };\n        // Update local state immediately\n        dispatch({\n          type: 'UPDATE_VEHICLE',\n          payload: updatedVehicle\n        });\n      }\n\n      // Reload all user data to ensure everything is in sync\n      if (state.currentUser) {\n        await loadUserData(state.currentUser.id);\n      }\n\n      // Also refresh all listings to ensure new listing appears immediately\n      await loadAllListings(true);\n    } catch (error) {\n      console.error('Error adding listing:', error);\n    }\n  };\n  const updateListing = async updatedListing => {\n    try {\n      const listing = await ApiService.updateListing(updatedListing.id, updatedListing);\n      dispatch({\n        type: 'UPDATE_LISTING',\n        payload: listing\n      });\n\n      // Reload user data to ensure everything is in sync\n      if (state.currentUser) {\n        await loadUserData(state.currentUser.id);\n      }\n\n      // Also refresh all listings to ensure price changes are visible immediately\n      await loadAllListings(true);\n    } catch (error) {\n      console.error('Error updating listing:', error);\n    }\n  };\n  const deleteListing = async listingId => {\n    try {\n      await ApiService.deleteListing(listingId);\n      dispatch({\n        type: 'DELETE_LISTING',\n        payload: listingId\n      });\n\n      // Reload user data to ensure everything is in sync\n      if (state.currentUser) {\n        await loadUserData(state.currentUser.id);\n      }\n    } catch (error) {\n      console.error('Error deleting listing:', error);\n    }\n  };\n  const renewListing = async listingId => {\n    try {\n      const response = await ApiService.renewListing(listingId);\n      const renewedListing = {\n        ...response.listing,\n        id: response.listing.id\n      };\n      dispatch({\n        type: 'UPDATE_LISTING',\n        payload: renewedListing\n      });\n\n      // Reload user data to ensure everything is in sync\n      if (state.currentUser) {\n        await loadUserData(state.currentUser.id);\n      }\n\n      // Also refresh all listings to show updated renewal time\n      await loadAllListings(true);\n    } catch (error) {\n      console.error('Error renewing listing:', error);\n    }\n  };\n  const incrementListingViews = async listingId => {\n    try {\n      // The backend automatically increments views when getting a listing\n      await ApiService.getListing(listingId);\n\n      // Update local state by incrementing views\n      const listing = state.listings.find(l => l.id === listingId);\n      if (listing) {\n        const updatedListing = {\n          ...listing,\n          views: listing.views + 1,\n          updatedAt: new Date().toISOString()\n        };\n        dispatch({\n          type: 'UPDATE_LISTING',\n          payload: updatedListing\n        });\n      }\n    } catch (error) {\n      console.error('Error incrementing listing views:', error);\n    }\n  };\n  const addReview = async reviewData => {\n    try {\n      const response = await ApiService.createReview(reviewData);\n      // Reload all data to update ratings\n      await loadAllListings();\n    } catch (error) {\n      console.error('Error adding review:', error);\n    }\n  };\n  const getUserProfile = userId => {\n    // Try direct match first\n    let user = state.users.find(u => u.id === userId);\n\n    // If not found, try matching with MongoDB ObjectId format\n    if (!user) {\n      user = state.users.find(u => {\n        const uId = u._id || u.id;\n        return uId === userId;\n      });\n    }\n    return user || null;\n  };\n  const sendMessage = async messageData => {\n    try {\n      const newMessage = await ApiService.sendMessage(messageData);\n\n      // Immediately add the message to state\n      dispatch({\n        type: 'ADD_MESSAGE',\n        payload: newMessage\n      });\n\n      // Ensure both sender and receiver users are loaded\n      const userIdsToLoad = [messageData.senderId, messageData.receiverId].filter(id => id && !state.users.find(u => u.id === id));\n      if (userIdsToLoad.length > 0) {\n        try {\n          const users = await ApiService.getUsersBatch(userIdsToLoad);\n          const usersWithId = users.map(u => ({\n            ...u,\n            id: u._id || u.id\n          }));\n\n          // Add new users to existing users\n          const allUsers = [...state.users];\n          usersWithId.forEach(user => {\n            if (!allUsers.find(u => u.id === user.id)) {\n              allUsers.push(user);\n            }\n          });\n          dispatch({\n            type: 'SET_USERS',\n            payload: allUsers\n          });\n        } catch (error) {\n          console.error('Error loading users for message:', error);\n        }\n      }\n    } catch (error) {\n      console.error('Error sending message:', error);\n    }\n  };\n  const markMessagesAsRead = async conversationId => {\n    if (!state.currentUser) return;\n    try {\n      await ApiService.markMessagesAsRead(conversationId);\n      await loadUserMessages();\n    } catch (error) {\n      console.error('Error marking messages as read:', error);\n    }\n  };\n  const loadUserMessages = async () => {\n    try {\n      const messages = await ApiService.getUserMessages();\n      dispatch({\n        type: 'SET_MESSAGES',\n        payload: messages\n      });\n\n      // Extract users from populated message objects and collect missing user IDs\n      const userIds = new Set();\n      const usersFromMessages = [];\n      messages.forEach(message => {\n        // Handle populated sender\n        if (typeof message.senderId === 'object' && message.senderId && message.senderId.id) {\n          const senderUser = {\n            ...message.senderId,\n            id: message.senderId.id\n          };\n          usersFromMessages.push(senderUser);\n          userIds.add(senderUser.id);\n        } else if (typeof message.senderId === 'string') {\n          userIds.add(message.senderId);\n        }\n\n        // Handle populated receiver\n        if (typeof message.receiverId === 'object' && message.receiverId && message.receiverId.id) {\n          const receiverUser = {\n            ...message.receiverId,\n            id: message.receiverId.id\n          };\n          usersFromMessages.push(receiverUser);\n          userIds.add(receiverUser.id);\n        } else if (typeof message.receiverId === 'string') {\n          userIds.add(message.receiverId);\n        }\n      });\n      console.log('👥 Extracted user IDs from messages:', Array.from(userIds));\n      console.log('👥 Current users in state:', state.users.map(u => ({\n        id: u.id,\n        username: u.username\n      })));\n\n      // Load users that aren't already in state\n      const missingUserIds = Array.from(userIds).filter(id => !state.users.find(u => u.id === id));\n      console.log('❓ Missing user IDs:', missingUserIds);\n      if (missingUserIds.length > 0) {\n        try {\n          console.log('🔍 Loading missing users via batch API...');\n          const users = await ApiService.getUsersBatch(missingUserIds);\n          console.log('✅ Loaded users from batch API:', users.map(u => ({\n            id: u.id,\n            username: u.username\n          })));\n\n          // Add new users to existing users\n          const allUsers = [...state.users];\n          users.forEach(user => {\n            if (!allUsers.find(u => u.id === user.id)) {\n              allUsers.push(user);\n            }\n          });\n          console.log('👥 Updated users state:', allUsers.map(u => ({\n            id: u.id,\n            username: u.username\n          })));\n          dispatch({\n            type: 'SET_USERS',\n            payload: allUsers\n          });\n        } catch (error) {\n          console.error('❌ Error loading missing users:', error);\n          // Fallback: load all users\n          console.log('🔄 Falling back to loading all users...');\n          await loadAllUsers();\n        }\n      } else {\n        console.log('✅ All required users already in state');\n      }\n    } catch (error) {\n      console.error('❌ Error loading messages:', error);\n    }\n  };\n\n  // Load messages only when messages tab is accessed\n  const loadMessagesOnTabSwitch = async () => {\n    try {\n      console.log('🔄 Loading messages for messages tab...');\n\n      // Load both messages and conversations\n      const [messages, conversations] = await Promise.all([ApiService.getUserMessages(), ApiService.getConversations()]);\n      console.log('📨 Loaded messages from API:', {\n        count: messages.length,\n        samples: messages.slice(0, 3).map(m => ({\n          id: m.id,\n          senderId: m.senderId,\n          receiverId: m.receiverId,\n          content: m.content.substring(0, 30)\n        }))\n      });\n      console.log('💬 Loaded conversations from API:', {\n        count: conversations.length,\n        samples: conversations.slice(0, 3).map(c => {\n          var _c$lastMessage, _c$lastMessage$conten;\n          return {\n            id: c.id,\n            participants: c.participants,\n            lastMessage: (_c$lastMessage = c.lastMessage) === null || _c$lastMessage === void 0 ? void 0 : (_c$lastMessage$conten = _c$lastMessage.content) === null || _c$lastMessage$conten === void 0 ? void 0 : _c$lastMessage$conten.substring(0, 30)\n          };\n        })\n      });\n      dispatch({\n        type: 'SET_MESSAGES',\n        payload: messages\n      });\n      dispatch({\n        type: 'SET_CONVERSATIONS',\n        payload: conversations\n      });\n\n      // Extract users from populated message objects and conversations\n      const userIds = new Set();\n      const usersFromMessages = [];\n      messages.forEach(message => {\n        // Handle populated sender\n        if (typeof message.senderId === 'object' && message.senderId && message.senderId.id) {\n          const senderUser = {\n            ...message.senderId,\n            id: message.senderId.id\n          };\n          usersFromMessages.push(senderUser);\n          userIds.add(senderUser.id);\n        } else if (typeof message.senderId === 'string') {\n          userIds.add(message.senderId);\n        }\n\n        // Handle populated receiver\n        if (typeof message.receiverId === 'object' && message.receiverId && message.receiverId.id) {\n          const receiverUser = {\n            ...message.receiverId,\n            id: message.receiverId.id\n          };\n          usersFromMessages.push(receiverUser);\n          userIds.add(receiverUser.id);\n        } else if (typeof message.receiverId === 'string') {\n          userIds.add(message.receiverId);\n        }\n      });\n\n      // Extract users from conversations\n      conversations.forEach(conversation => {\n        // Add otherUser from conversation\n        if (conversation.otherUser) {\n          const otherUser = {\n            ...conversation.otherUser\n          };\n          usersFromMessages.push(otherUser);\n          userIds.add(otherUser.id);\n        }\n\n        // Also add participant IDs in case they're not populated\n        if (conversation.participants) {\n          conversation.participants.forEach(participantId => {\n            if (typeof participantId === 'string') {\n              userIds.add(participantId);\n            }\n          });\n        }\n      });\n      console.log('👥 Extracted user IDs from messages and conversations:', Array.from(userIds));\n      console.log('👥 Users from populated messages and conversations:', usersFromMessages.map(u => ({\n        id: u.id,\n        username: u.username\n      })));\n      console.log('👥 Current users in state:', state.users.map(u => ({\n        id: u.id,\n        username: u.username\n      })));\n\n      // Add populated users to state first\n      let allUsers = [...state.users];\n      usersFromMessages.forEach(user => {\n        if (!allUsers.find(u => u.id === user.id)) {\n          allUsers.push(user);\n        }\n      });\n\n      // Find users that still need to be fetched (not populated and not in state)\n      const missingUserIds = Array.from(userIds).filter(id => !allUsers.find(u => u.id === id));\n      console.log('❓ Missing user IDs after adding populated users:', missingUserIds);\n      if (missingUserIds.length > 0) {\n        try {\n          console.log('🔍 Loading missing users via batch API...');\n          const users = await ApiService.getUsersBatch(missingUserIds);\n          console.log('✅ Loaded users from batch API:', users.map(u => ({\n            id: u.id,\n            username: u.username\n          })));\n\n          // Add fetched users to existing users\n          users.forEach(user => {\n            if (!allUsers.find(u => u.id === user.id)) {\n              allUsers.push(user);\n            }\n          });\n        } catch (error) {\n          console.error('❌ Error loading missing users:', error);\n          // Fallback: load all users\n          console.log('🔄 Falling back to loading all users...');\n          await loadAllUsers();\n          return; // Exit early since loadAllUsers will update state\n        }\n      }\n      console.log('👥 Final updated users state:', allUsers.map(u => ({\n        id: u.id,\n        username: u.username\n      })));\n      dispatch({\n        type: 'SET_USERS',\n        payload: allUsers\n      });\n    } catch (error) {\n      console.error('❌ Error loading messages:', error);\n    }\n  };\n  const addTrade = async tradeData => {\n    try {\n      const newTrade = await ApiService.createTrade(tradeData);\n\n      // Convert MongoDB _id to id for frontend compatibility\n      const mongoTrade = newTrade;\n      const tradeWithId = {\n        ...newTrade,\n        id: mongoTrade._id || newTrade.id\n      };\n      dispatch({\n        type: 'ADD_TRADE',\n        payload: tradeWithId\n      });\n    } catch (error) {\n      console.error('❌ Error adding trade:', error);\n      throw error; // Re-throw so the calling component can handle it\n    }\n  };\n  const updateTrade = async (tradeOrId, tradeData) => {\n    try {\n      let tradeId;\n      let updatedTradeData;\n\n      // Handle both old format (full trade object) and new format (id + data)\n      if (typeof tradeOrId === 'string') {\n        tradeId = tradeOrId;\n        updatedTradeData = tradeData;\n      } else {\n        tradeId = tradeOrId.id;\n        updatedTradeData = tradeOrId;\n      }\n\n      // If trade is being cancelled, it gets deleted on the backend\n      if (updatedTradeData.status === 'cancelled') {\n        const result = await ApiService.updateTrade(tradeId, updatedTradeData);\n        // Remove the cancelled trade from state since backend deletes it\n        dispatch({\n          type: 'SET_TRADES',\n          payload: state.trades.filter(t => t.id !== tradeId)\n        });\n        console.log('✅ Cancelled trade removed from state');\n      } else {\n        const trade = await ApiService.updateTrade(tradeId, updatedTradeData);\n        dispatch({\n          type: 'UPDATE_TRADE',\n          payload: trade\n        });\n\n        // If trade is completed, reload listings to remove sold listing\n        if (updatedTradeData.status === 'completed') {\n          console.log('🔄 Trade completed, reloading listings to update sold status');\n          await loadAllListings(true); // Force refresh\n        }\n      }\n    } catch (error) {\n      console.error('Error updating trade:', error);\n      throw error; // Re-throw so the calling component can handle it\n    }\n  };\n  const deleteTrade = async tradeId => {\n    try {\n      await ApiService.deleteTrade(tradeId);\n      // Remove the deleted trade from state\n      dispatch({\n        type: 'SET_TRADES',\n        payload: state.trades.filter(t => t.id !== tradeId)\n      });\n      console.log('✅ Deleted trade removed from state');\n    } catch (error) {\n      console.error('Error deleting trade:', error);\n      throw error; // Re-throw so the calling component can handle it\n    }\n  };\n  const cleanupCorruptedTrades = async () => {\n    try {\n      const result = await ApiService.cleanupCorruptedTrades();\n      console.log('Cleanup result:', result);\n\n      // Reload trades to reflect the cleanup\n      if (state.currentUser) {\n        await loadUserData(state.currentUser.id);\n      }\n      return result;\n    } catch (error) {\n      console.error('Error cleaning up corrupted trades:', error);\n      throw error;\n    }\n  };\n  const cleanupVehicleFlags = async () => {\n    try {\n      const result = await ApiService.cleanupVehicleFlags();\n      console.log('Vehicle cleanup result:', result);\n\n      // Reload user data to reflect the cleanup\n      if (state.currentUser) {\n        await loadUserData(state.currentUser.id);\n      }\n      return result;\n    } catch (error) {\n      console.error('Error cleaning up vehicle flags:', error);\n      throw error;\n    }\n  };\n\n  // Memoize the context value to prevent unnecessary re-renders\n  const contextValue = useMemo(() => ({\n    state,\n    dispatch,\n    login,\n    register,\n    logout,\n    updateUser,\n    addVehicle,\n    updateVehicle,\n    deleteVehicle,\n    getUserVehicles: async userId => {\n      try {\n        const vehicles = await ApiService.getVehiclesByUserId(userId);\n        return vehicles;\n      } catch (error) {\n        console.error('Error getting user vehicles:', error);\n        return [];\n      }\n    },\n    getVehiclesCount: async () => {\n      try {\n        const result = await ApiService.getUserVehiclesCount();\n        return result.count;\n      } catch (error) {\n        console.error('Error getting vehicles count:', error);\n        return 0;\n      }\n    },\n    addListing,\n    updateListing,\n    deleteListing,\n    renewListing,\n    incrementListingViews,\n    loadAllListings,\n    getListingsCount: async () => {\n      try {\n        const result = await ApiService.getAllListingsCount();\n        return result.count;\n      } catch (error) {\n        console.error('Error getting listings count:', error);\n        return 0;\n      }\n    },\n    addReview,\n    getUserProfile,\n    sendMessage,\n    markMessagesAsRead,\n    addTrade,\n    updateTrade,\n    deleteTrade,\n    cleanupCorruptedTrades,\n    cleanupVehicleFlags,\n    activeTab,\n    setActiveTab,\n    reloadTrades,\n    loadUserMessages,\n    loadMessagesOnTabSwitch\n  }), [state, dispatch, login, logout, updateUser, addVehicle, updateVehicle, deleteVehicle, addListing, updateListing, deleteListing, renewListing, incrementListingViews, loadAllListings, addReview, getUserProfile, sendMessage, markMessagesAsRead, addTrade, updateTrade, deleteTrade, cleanupCorruptedTrades, cleanupVehicleFlags, activeTab, setActiveTab, reloadTrades, loadUserMessages, loadMessagesOnTabSwitch]);\n  return /*#__PURE__*/_jsxDEV(AppContext.Provider, {\n    value: contextValue,\n    children: children\n  }, void 0, false, {\n    fileName: _jsxFileName,\n    lineNumber: 1264,\n    columnNumber: 10\n  }, this);\n}\n_s(AppProvider, \"gKGaTruyQerMyxehsnIrW7Bw56g=\");\n_c = AppProvider;\nexport function useApp() {\n  _s2();\n  const context = useContext(AppContext);\n  if (context === undefined) {\n    throw new Error('useApp must be used within an AppProvider');\n  }\n  return context;\n}\n_s2(useApp, \"b9L3QQ+jgeyIrH0NfHrJ8nn7VMU=\");\nvar _c;\n$RefreshReg$(_c, \"AppProvider\");","map":{"version":3,"names":["React","createContext","useContext","useReducer","useEffect","useState","useMemo","useCallback","AuthService","ApiService","jsxDEV","_jsxDEV","initialState","currentUser","vehicles","listings","allListings","auctions","trades","messages","conversations","reviews","sales","users","isAuthenticated","loading","error","appReducer","state","action","type","payload","map","v","id","filter","l","t","console","log","length","slice","c","participants","otherUser","username","AppContext","undefined","AppProvider","children","_s","dispatch","activeTab","setActiveTab","listingsCache","setListingsCache","data","timestamp","ttl","loadingStates","setLoadingStates","userData","messagesCache","setMessagesCache","initializeAuth","token","localStorage","getItem","authCheck","verifyToken","valid","user","_id","loadUserData","logout","userId","prev","Promise","all","getUserVehicles","getUserListings","getUserTrades","vehiclesWithId","listingsWithId","usersFromTrades","userIds","Set","tradesWithId","trade","offererVehicleIds","Array","isArray","offererVehicleObjects","make","receiverVehicleIds","receiverVehicleObjects","offererUserId","offererUser","push","add","receiverUserId","receiverUser","listingId","u","allUsers","forEach","find","missingUserIds","from","getUsersBatch","loadUserMessages","reloadTrades","loadAllUsers","getAllUsers","usersWithId","loadUsersIfNeeded","updatedUsers","loadAllListings","forceRefresh","now","Date","response","getAllListings","listing","vehicleId","sellerId","vehicle","seller","sellerIds","login","password","rememberMe","success","message","removeItem","register","updateUser","addVehicle","vehicleData","newVehicle","createVehicle","mongoVehicle","vehicleWithId","isListed","isAuctioned","updateVehicle","updatedVehicle","deleteVehicle","addListing","listingData","newListing","createListing","mongoListing","listingWithId","updatedAt","toISOString","updateListing","updatedListing","deleteListing","renewListing","renewedListing","incrementListingViews","getListing","views","addReview","reviewData","createReview","getUserProfile","uId","sendMessage","messageData","newMessage","userIdsToLoad","senderId","receiverId","markMessagesAsRead","conversationId","getUserMessages","usersFromMessages","senderUser","loadMessagesOnTabSwitch","getConversations","count","samples","m","content","substring","_c$lastMessage","_c$lastMessage$conten","lastMessage","conversation","participantId","addTrade","tradeData","newTrade","createTrade","mongoTrade","tradeWithId","updateTrade","tradeOrId","tradeId","updatedTradeData","status","result","deleteTrade","cleanupCorruptedTrades","cleanupVehicleFlags","contextValue","getVehiclesByUserId","getVehiclesCount","getUserVehiclesCount","getListingsCount","getAllListingsCount","Provider","value","fileName","_jsxFileName","lineNumber","columnNumber","_c","useApp","_s2","context","Error","$RefreshReg$"],"sources":["C:/Users/thato/Downloads/car-app/src/context/AppContext.tsx"],"sourcesContent":["import React, { createContext, useContext, useReducer, useEffect, ReactNode, useState, useMemo, useCallback } from 'react';\nimport { AppState, User, Vehicle, Listing, Auction, Trade, Message, Conversation, Review, NavigationTab } from '../types/index.ts';\nimport { AuthService } from '../services/authService.ts';\nimport { DataService } from '../services/dataService.ts';\nimport ApiService from '../services/apiService.ts';\n\ninterface AppContextType {\n  state: AppState;\n  dispatch: React.Dispatch<AppAction>;\n  login: (username: string, password: string, rememberMe?: boolean) => Promise<{ success: boolean; error?: string }>;\n  register: (userData: Omit<User, 'id' | 'createdAt'>) => Promise<{ success: boolean; error?: string }>;\n  logout: () => void;\n  updateUser: (user: User) => void;\n  addVehicle: (vehicle: {\n    make: string;\n    model: string;\n    year: number;\n    vin: string;\n    mileage: number;\n    transmission: 'manual' | 'automatic';\n    estimatedValue: number;\n    customPrice?: number;\n    images?: string[];\n  }) => Promise<void>;\n  updateVehicle: (vehicle: Vehicle) => Promise<void>;\n  deleteVehicle: (vehicleId: string) => Promise<void>;\n  getUserVehicles: (userId: string) => Promise<Vehicle[]>;\n  getVehiclesCount: () => Promise<number>;\n  addListing: (listing: Omit<Listing, 'id' | 'createdAt' | 'updatedAt' | 'views'>) => Promise<void>;\n  updateListing: (listing: Listing) => Promise<void>;\n  deleteListing: (listingId: string) => Promise<void>;\n  renewListing: (listingId: string) => Promise<void>;\n  incrementListingViews: (listingId: string) => Promise<void>;\n  loadAllListings: (forceRefresh?: boolean) => Promise<void>;\n  getListingsCount: () => Promise<number>;\n  addReview: (review: Omit<Review, 'id' | 'createdAt'>) => Promise<void>;\n  getUserProfile: (userId: string) => User | null;\n  sendMessage: (message: Omit<Message, 'id' | 'timestamp' | 'read'>) => Promise<void>;\n  markMessagesAsRead: (conversationId: string) => Promise<void>;\n  addTrade: (trade: Omit<Trade, 'id' | 'createdAt' | 'updatedAt'>) => Promise<void>;\n  updateTrade: (tradeOrId: Trade | string, tradeData?: Partial<Trade>) => Promise<void>;\n  deleteTrade: (tradeId: string) => Promise<void>;\n  reloadTrades: () => Promise<void>;\n  cleanupCorruptedTrades: () => Promise<{ message: string; deletedCount: number; deletedTradeIds: string[] }>;\n  cleanupVehicleFlags: () => Promise<{ message: string; cleanedCount: number }>;\n  activeTab: NavigationTab;\n  setActiveTab: (tab: NavigationTab) => void;\n  loadUserMessages: () => Promise<void>;\n  loadMessagesOnTabSwitch: () => Promise<void>;\n}\n\ntype AppAction = \n  | { type: 'SET_USER'; payload: User | null }\n  | { type: 'SET_CURRENT_USER'; payload: User }\n  | { type: 'LOGOUT' }\n  | { type: 'SET_LOADING'; payload: boolean }\n  | { type: 'SET_ERROR'; payload: string | null }\n  | { type: 'SET_VEHICLES'; payload: Vehicle[] }\n  | { type: 'ADD_VEHICLE'; payload: Vehicle }\n  | { type: 'UPDATE_VEHICLE'; payload: Vehicle }\n  | { type: 'DELETE_VEHICLE'; payload: string }\n  | { type: 'SET_LISTINGS'; payload: Listing[] }\n  | { type: 'SET_ALL_LISTINGS'; payload: Listing[] }\n  | { type: 'ADD_LISTING'; payload: Listing }\n  | { type: 'UPDATE_LISTING'; payload: Listing }\n  | { type: 'DELETE_LISTING'; payload: string }\n  | { type: 'SET_TRADES'; payload: Trade[] }\n  | { type: 'ADD_TRADE'; payload: Trade }\n  | { type: 'UPDATE_TRADE'; payload: Trade }\n  | { type: 'SET_MESSAGES'; payload: Message[] }\n  | { type: 'ADD_MESSAGE'; payload: Message }\n  | { type: 'SET_CONVERSATIONS'; payload: Conversation[] }\n  | { type: 'SET_REVIEWS'; payload: Review[] }\n  | { type: 'SET_USERS'; payload: User[] }\n  | { type: 'SET_ACTIVE_TAB'; payload: NavigationTab };\n\nconst initialState: AppState = {\n  currentUser: null,\n  vehicles: [],\n  listings: [],\n  allListings: [],\n  auctions: [],\n  trades: [],\n  messages: [],\n  conversations: [],\n  reviews: [],\n  sales: [],\n  users: [],\n  isAuthenticated: false,\n  loading: false,\n  error: null,\n};\n\nfunction appReducer(state: AppState, action: AppAction): AppState {\n  switch (action.type) {\n    case 'SET_USER':\n      return {\n        ...state,\n        currentUser: action.payload,\n        isAuthenticated: action.payload !== null,\n      };\n    case 'SET_CURRENT_USER':\n      return {\n        ...state,\n        currentUser: action.payload,\n        isAuthenticated: true,\n      };\n    case 'LOGOUT':\n      return {\n        ...initialState, // Reset to initial state\n        isAuthenticated: false,\n      };\n    case 'SET_LOADING':\n      return { ...state, loading: action.payload };\n    case 'SET_ERROR':\n      return { ...state, error: action.payload };\n    case 'SET_VEHICLES':\n      return { ...state, vehicles: action.payload };\n    case 'ADD_VEHICLE':\n      return { ...state, vehicles: [...state.vehicles, action.payload] };\n    case 'UPDATE_VEHICLE':\n      return {\n        ...state,\n        vehicles: state.vehicles.map(v => v.id === action.payload.id ? action.payload : v),\n      };\n    case 'DELETE_VEHICLE':\n      return {\n        ...state,\n        vehicles: state.vehicles.filter(v => v.id !== action.payload),\n      };\n    case 'SET_LISTINGS':\n      return { ...state, listings: action.payload };\n    case 'ADD_LISTING':\n      return { ...state, listings: [...state.listings, action.payload] };\n    case 'UPDATE_LISTING':\n      return {\n        ...state,\n        listings: state.listings.map(l => l.id === action.payload.id ? action.payload : l),\n      };\n    case 'DELETE_LISTING':\n      return {\n        ...state,\n        listings: state.listings.filter(l => l.id !== action.payload),\n      };\n    case 'SET_TRADES':\n      return { ...state, trades: action.payload };\n    case 'ADD_TRADE':\n      return { ...state, trades: [...state.trades, action.payload] };\n    case 'UPDATE_TRADE':\n      return {\n        ...state,\n        trades: state.trades.map(t => t.id === action.payload.id ? action.payload : t),\n      };\n    case 'SET_MESSAGES':\n      return { ...state, messages: action.payload };\n    case 'ADD_MESSAGE':\n      return { ...state, messages: [...state.messages, action.payload] };\n    case 'SET_CONVERSATIONS':\n      console.log('📞 Setting conversations in state:', action.payload.length, 'conversations');\n      console.log('📞 Sample conversations:', action.payload.slice(0, 2).map(c => ({\n        id: c.id,\n        participants: c.participants,\n        otherUser: (c as any).otherUser ? {\n          id: (c as any).otherUser.id,\n          username: (c as any).otherUser.username\n        } : null\n      })));\n      return { ...state, conversations: action.payload };\n    case 'SET_REVIEWS':\n      return { ...state, reviews: action.payload };\n    case 'SET_USERS':\n      return { ...state, users: action.payload };\n    case 'SET_ALL_LISTINGS':\n      return { ...state, allListings: action.payload };\n    default:\n      return state;\n  }\n}\n\nconst AppContext = createContext<AppContextType | undefined>(undefined);\n\ninterface AppProviderProps {\n  children: ReactNode;\n}\n\nexport function AppProvider({ children }: AppProviderProps) {\n  const [state, dispatch] = useReducer(appReducer, initialState);\n  const [activeTab, setActiveTab] = React.useState<NavigationTab>('garage');\n  const [listingsCache, setListingsCache] = useState<{\n    data: any[];\n    timestamp: number;\n    ttl: number;\n  }>({ data: [], timestamp: 0, ttl: 30000 }); // 30 second cache\n  \n  // Add loading states to prevent duplicate calls\n  const [loadingStates, setLoadingStates] = useState<{\n    userData: boolean;\n    users: boolean;\n    listings: boolean;\n    messages: boolean;\n  }>({ userData: false, users: false, listings: false, messages: false });\n\n  // Add messages cache\n  const [messagesCache, setMessagesCache] = useState<{\n    messages: Message[];\n    conversations: Conversation[];\n    timestamp: number;\n    ttl: number;\n  }>({ messages: [], conversations: [], timestamp: 0, ttl: 60000 }); // 1 minute cache\n\n  useEffect(() => {\n    // Initialize app state by checking API authentication\n    const initializeAuth = async () => {\n      try {\n        // Only check if there's a token present\n        const token = localStorage.getItem('carTrade_token');\n        if (!token) {\n          return;\n        }\n\n        const authCheck = await ApiService.verifyToken();\n        if (authCheck.valid && authCheck.user) {\n          const user = { ...authCheck.user, id: (authCheck.user as any)._id || authCheck.user.id };\n          dispatch({ type: 'SET_CURRENT_USER', payload: user });\n          await loadUserData(user.id);\n        } else {\n          ApiService.logout();\n          AuthService.logout();\n        }\n      } catch (error) {\n        // Clear any stale tokens on error\n        ApiService.logout();\n        AuthService.logout();\n        dispatch({ type: 'LOGOUT' });\n      }\n    };\n\n    initializeAuth();\n    // DON'T load all users on startup - load them when needed\n  }, []);\n\n  const loadUserData = async (userId: string) => {\n    // Prevent duplicate calls\n    if (loadingStates.userData) {\n      console.log('⏳ User data already loading, skipping duplicate call');\n      return;\n    }\n\n    setLoadingStates(prev => ({ ...prev, userData: true }));\n    \n    try {\n      const [vehicles, listings, trades] = await Promise.all([\n        ApiService.getUserVehicles(),\n        ApiService.getUserListings(),\n        ApiService.getUserTrades()\n      ]);\n\n      console.log('📊 Loaded trades from API:', trades.length);\n\n      // Convert MongoDB _id to id for frontend compatibility\n      const vehiclesWithId = vehicles.map((v: any) => ({ ...v, id: v._id || v.id }));\n      const listingsWithId = listings.map((l: any) => ({ ...l, id: l._id || l.id }));\n      // Extract users from populated trade objects\n      const usersFromTrades: any[] = [];\n      const userIds = new Set<string>();\n      \n      const tradesWithId = trades.map((t: any) => {\n        const trade = { ...t, id: t._id || t.id };\n        \n        // Handle populated vehicle arrays - preserve vehicle data for display\n        // but also create ID arrays for consistency\n        if (trade.offererVehicleIds && Array.isArray(trade.offererVehicleIds)) {\n          // Store the populated vehicle objects for later reference\n          trade.offererVehicleObjects = trade.offererVehicleIds.filter((v: any) => \n            typeof v === 'object' && v.make\n          ).map((v: any) => ({ ...v, id: v._id || v.id }));\n          \n          // Convert to IDs for consistency\n          trade.offererVehicleIds = trade.offererVehicleIds.map((v: any) => \n            typeof v === 'object' ? (v._id || v.id) : v\n          );\n        }\n        \n        if (trade.receiverVehicleIds && Array.isArray(trade.receiverVehicleIds)) {\n          // Store the populated vehicle objects for later reference\n          trade.receiverVehicleObjects = trade.receiverVehicleIds.filter((v: any) => \n            typeof v === 'object' && v.make\n          ).map((v: any) => ({ ...v, id: v._id || v.id }));\n          \n          // Convert to IDs for consistency\n          trade.receiverVehicleIds = trade.receiverVehicleIds.map((v: any) => \n            typeof v === 'object' ? (v._id || v.id) : v\n          );\n        }\n        \n        // Handle populated user objects - extract user data before converting to IDs\n        if (trade.offererUserId && typeof trade.offererUserId === 'object') {\n          const offererUser = { ...trade.offererUserId, id: trade.offererUserId._id || trade.offererUserId.id };\n          usersFromTrades.push(offererUser);\n          userIds.add(offererUser.id);\n          trade.offererUserId = offererUser.id;\n        } else if (typeof trade.offererUserId === 'string') {\n          userIds.add(trade.offererUserId);\n        }\n        \n        if (trade.receiverUserId && typeof trade.receiverUserId === 'object') {\n          const receiverUser = { ...trade.receiverUserId, id: trade.receiverUserId._id || trade.receiverUserId.id };\n          usersFromTrades.push(receiverUser);\n          userIds.add(receiverUser.id);\n          trade.receiverUserId = receiverUser.id;\n        } else if (typeof trade.receiverUserId === 'string') {\n          userIds.add(trade.receiverUserId);\n        }\n        \n        // Handle populated listing object\n        if (trade.listingId && typeof trade.listingId === 'object') {\n          trade.listingId = trade.listingId._id || trade.listingId.id;\n        }\n        \n        return trade;\n      });\n\n      dispatch({ type: 'SET_VEHICLES', payload: vehiclesWithId });\n      dispatch({ type: 'SET_LISTINGS', payload: listingsWithId });\n      dispatch({ type: 'SET_TRADES', payload: tradesWithId });\n      \n      console.log('👥 Extracted users from initial trades:', usersFromTrades.map(u => ({ id: u.id, username: u.username })));\n      \n      // Add extracted users to state\n      let allUsers = [...state.users];\n      usersFromTrades.forEach(user => {\n        if (!allUsers.find(u => u.id === user.id)) {\n          allUsers.push(user);\n        }\n      });\n      \n      // Find users that still need to be fetched\n      const missingUserIds = Array.from(userIds).filter(id => \n        !allUsers.find(u => u.id === id)\n      );\n      \n      if (missingUserIds.length > 0) {\n        try {\n          console.log('🔍 Loading missing initial trade users via batch API...');\n          const users = await ApiService.getUsersBatch(missingUserIds);\n          console.log('✅ Loaded missing initial trade users:', users.map(u => ({ id: u.id, username: u.username })));\n          \n          // Add fetched users to existing users\n          users.forEach(user => {\n            if (!allUsers.find(u => u.id === user.id)) {\n              allUsers.push(user);\n            }\n          });\n        } catch (error) {\n          console.error('❌ Error loading missing initial trade users:', error);\n        }\n      }\n      \n      dispatch({ type: 'SET_USERS', payload: allUsers });\n      \n      // Load messages and associated users separately\n      await loadUserMessages();\n      \n    } catch (error) {\n      console.error('Error loading user data:', error);\n    } finally {\n      setLoadingStates(prev => ({ ...prev, userData: false }));\n    }\n  };\n\n  // Add a function to force reload trades specifically\n  const reloadTrades = async () => {\n    try {\n      console.log('🔄 Force reloading trades...');\n      const trades = await ApiService.getUserTrades();\n      console.log('📊 Reloaded trades from API:', trades.length);\n      \n      // Extract users from populated trade objects\n      const usersFromTrades: any[] = [];\n      const userIds = new Set<string>();\n      \n      const tradesWithId = trades.map((t: any) => {\n        const trade = { ...t, id: t._id || t.id };\n        \n        // Handle populated vehicle arrays - preserve vehicle data for display\n        // but also create ID arrays for consistency\n        if (trade.offererVehicleIds && Array.isArray(trade.offererVehicleIds)) {\n          // Store the populated vehicle objects for later reference\n          trade.offererVehicleObjects = trade.offererVehicleIds.filter((v: any) => \n            typeof v === 'object' && v.make\n          ).map((v: any) => ({ ...v, id: v._id || v.id }));\n          \n          // Convert to IDs for consistency\n          trade.offererVehicleIds = trade.offererVehicleIds.map((v: any) => \n            typeof v === 'object' ? (v._id || v.id) : v\n          );\n        }\n        \n        if (trade.receiverVehicleIds && Array.isArray(trade.receiverVehicleIds)) {\n          // Store the populated vehicle objects for later reference\n          trade.receiverVehicleObjects = trade.receiverVehicleIds.filter((v: any) => \n            typeof v === 'object' && v.make\n          ).map((v: any) => ({ ...v, id: v._id || v.id }));\n          \n          // Convert to IDs for consistency\n          trade.receiverVehicleIds = trade.receiverVehicleIds.map((v: any) => \n            typeof v === 'object' ? (v._id || v.id) : v\n          );\n        }\n        \n        // Handle populated user objects - extract user data before converting to IDs\n        if (trade.offererUserId && typeof trade.offererUserId === 'object') {\n          const offererUser = { ...trade.offererUserId, id: trade.offererUserId._id || trade.offererUserId.id };\n          usersFromTrades.push(offererUser);\n          userIds.add(offererUser.id);\n          trade.offererUserId = offererUser.id;\n        } else if (typeof trade.offererUserId === 'string') {\n          userIds.add(trade.offererUserId);\n        }\n        \n        if (trade.receiverUserId && typeof trade.receiverUserId === 'object') {\n          const receiverUser = { ...trade.receiverUserId, id: trade.receiverUserId._id || trade.receiverUserId.id };\n          usersFromTrades.push(receiverUser);\n          userIds.add(receiverUser.id);\n          trade.receiverUserId = receiverUser.id;\n        } else if (typeof trade.receiverUserId === 'string') {\n          userIds.add(trade.receiverUserId);\n        }\n        \n        // Handle populated listing object\n        if (trade.listingId && typeof trade.listingId === 'object') {\n          trade.listingId = trade.listingId._id || trade.listingId.id;\n        }\n        \n        return trade;\n      });\n      \n      console.log('👥 Extracted users from trades:', usersFromTrades.map(u => ({ id: u.id, username: u.username })));\n      console.log('👥 All user IDs needed for trades:', Array.from(userIds));\n      \n      // Update trades first\n      dispatch({ type: 'SET_TRADES', payload: tradesWithId });\n      \n      // Add extracted users to state\n      let allUsers = [...state.users];\n      usersFromTrades.forEach(user => {\n        if (!allUsers.find(u => u.id === user.id)) {\n          allUsers.push(user);\n        }\n      });\n      \n      // Find users that still need to be fetched\n      const missingUserIds = Array.from(userIds).filter(id => \n        !allUsers.find(u => u.id === id)\n      );\n      \n      console.log('❓ Missing user IDs after adding populated users:', missingUserIds);\n      \n      if (missingUserIds.length > 0) {\n        try {\n          console.log('🔍 Loading missing trade users via batch API...');\n          const users = await ApiService.getUsersBatch(missingUserIds);\n          console.log('✅ Loaded missing trade users:', users.map(u => ({ id: u.id, username: u.username })));\n          \n          // Add fetched users to existing users\n          users.forEach(user => {\n            if (!allUsers.find(u => u.id === user.id)) {\n              allUsers.push(user);\n            }\n          });\n        } catch (error) {\n          console.error('❌ Error loading missing trade users:', error);\n        }\n      }\n      \n      console.log('👥 Final users state after trade reload:', allUsers.map(u => ({ id: u.id, username: u.username })));\n      dispatch({ type: 'SET_USERS', payload: allUsers });\n      \n    } catch (error) {\n      console.error('Error reloading trades:', error);\n    }\n  };\n\n  const loadAllUsers = async () => {\n    // Prevent duplicate calls\n    if (loadingStates.users) {\n      console.log('⏳ Users already loading, skipping duplicate call');\n      return;\n    }\n\n    setLoadingStates(prev => ({ ...prev, users: true }));\n    \n    try {\n      const users = await ApiService.getAllUsers();\n      const usersWithId = users.map((u: any) => ({ \n        ...u, \n        id: u._id || u.id \n      }));\n      dispatch({ type: 'SET_USERS', payload: usersWithId });\n    } catch (error) {\n      console.error('Error loading users:', error);\n      // Fallback to empty array if API fails\n      dispatch({ type: 'SET_USERS', payload: [] });\n    } finally {\n      setLoadingStates(prev => ({ ...prev, users: false }));\n    }\n  };\n\n  // Lazy load specific users when needed\n  const loadUsersIfNeeded = useCallback(async (userIds: string[]) => {\n    const missingUserIds = userIds.filter(id => !state.users.find(u => u.id === id));\n    \n    if (missingUserIds.length === 0) {\n      return; // All users already loaded\n    }\n\n    // Prevent duplicate calls\n    if (loadingStates.users) {\n      return;\n    }\n\n    setLoadingStates(prev => ({ ...prev, users: true }));\n\n    try {\n      // Use efficient batch endpoint for specific users\n      const users = await ApiService.getUsersBatch(missingUserIds);\n      const usersWithId = users.map((u: any) => ({ \n        ...u, \n        id: u._id || u.id \n      }));\n      \n      // Merge with existing users\n      const updatedUsers = [...state.users, ...usersWithId];\n      dispatch({ type: 'SET_USERS', payload: updatedUsers });\n    } catch (error) {\n      console.error('Error loading users batch:', error);\n      // Fallback to loading all users if batch fails\n      if (state.users.length === 0) {\n        await loadAllUsers();\n      }\n    } finally {\n      setLoadingStates(prev => ({ ...prev, users: false }));\n    }\n  }, [state.users, loadingStates.users]);\n\n  // Memoize callback functions to prevent unnecessary re-renders\n  const loadAllListings = useCallback(async (forceRefresh: boolean = false) => {\n    // Prevent duplicate calls\n    if (loadingStates.listings && !forceRefresh) {\n      return;\n    }\n\n    setLoadingStates(prev => ({ ...prev, listings: true }));\n\n    try {\n      // Check cache first (unless force refresh)\n      const now = Date.now();\n      if (!forceRefresh && listingsCache.data.length > 0 && (now - listingsCache.timestamp) < listingsCache.ttl) {\n        dispatch({ type: 'SET_ALL_LISTINGS', payload: listingsCache.data });\n        return;\n      }\n\n      // Load all public listings from the API\n      const response = await ApiService.getAllListings();\n      \n      // Optimize data processing - avoid complex operations in map\n      const listingsWithId = response.listings.map((l: any) => {\n        // Simple ID conversion only\n        const listing = {\n          ...l, \n          id: l._id || l.id,\n          vehicleId: l.vehicleId,\n          sellerId: l.sellerId,\n        };\n        \n        // Add populated data if it exists from backend aggregation\n        if (l.vehicle && typeof l.vehicle === 'object' && l.vehicle._id) {\n          listing.vehicle = { \n            ...l.vehicle, \n            id: l.vehicle._id || l.vehicle.id \n          };\n        }\n        \n        if (l.seller && typeof l.seller === 'object' && l.seller._id) {\n          listing.seller = { \n            ...l.seller, \n            id: l.seller._id || l.seller.id \n          };\n        }\n        \n        return listing;\n      });\n      \n      // Extract unique seller IDs that need to be loaded\n      const sellerIds = [...new Set(listingsWithId.map(l => l.sellerId))];\n      \n      // Only load users if we don't have them yet\n      await loadUsersIfNeeded(sellerIds);\n      \n      // Update cache\n      setListingsCache({\n        data: listingsWithId,\n        timestamp: now,\n        ttl: 30000\n      });\n      \n      dispatch({ type: 'SET_ALL_LISTINGS', payload: listingsWithId });\n      \n    } catch (error) {\n      console.error('Error loading all listings:', error);\n      // Fallback to empty array if API fails\n      dispatch({ type: 'SET_ALL_LISTINGS', payload: [] });\n    } finally {\n      setLoadingStates(prev => ({ ...prev, listings: false }));\n    }\n  }, [listingsCache.data, listingsCache.timestamp, listingsCache.ttl, loadUsersIfNeeded, loadingStates.listings]);\n\n  // Memoize other frequently used functions\n  const login = useCallback(async (username: string, password: string, rememberMe: boolean = false) => {\n    try {\n      const response = await ApiService.login(username, password);\n      // The ApiService.login should automatically store the token\n      const user = { ...response.user, id: (response.user as any)._id || response.user.id };\n      dispatch({ type: 'SET_CURRENT_USER', payload: user });\n      // Load user data after successful login\n      await loadUserData(user.id);\n      return { success: true };\n    } catch (error: any) {\n      console.error('Login error:', error);\n      return { success: false, error: error.message || 'Login failed' };\n    }\n  }, []);\n\n  const logout = useCallback(() => {\n    // Clear both API token and AuthService localStorage data\n    ApiService.logout();\n    AuthService.logout();\n    \n    // Clear any additional auth-related localStorage items\n    localStorage.removeItem('carTrade_remember');\n    \n    dispatch({ type: 'LOGOUT' });\n    setActiveTab('garage');\n    // Clear cache on logout\n    setListingsCache({ data: [], timestamp: 0, ttl: 30000 });\n  }, []);\n\n  const register = useCallback(async (userData: Omit<User, 'id' | 'createdAt'>) => {\n    try {\n      const response = await ApiService.register(userData);\n      const user = { ...response.user, id: (response.user as any)._id || response.user.id };\n      dispatch({ type: 'SET_CURRENT_USER', payload: user });\n      // Load user data after successful registration\n      await loadUserData(user.id);\n      return { success: true };\n    } catch (error: any) {\n      console.error('Registration error:', error);\n      return { success: false, error: error.message || 'Registration failed' };\n    }\n  }, []);\n\n  const updateUser = (user: User) => {\n    try {\n      AuthService.updateUser(user);\n      dispatch({ type: 'SET_USER', payload: user });\n    } catch (error) {\n      console.error('Error in context updateUser:', error);\n      throw error;\n    }\n  };\n\n  const addVehicle = async (vehicleData: {\n    make: string;\n    model: string;\n    year: number;\n    vin: string;\n    mileage: number;\n    transmission: 'manual' | 'automatic';\n    estimatedValue: number;\n    customPrice?: number;\n    images?: string[];\n  }) => {\n    if (!state.currentUser) return;\n\n    try {\n      const newVehicle = await ApiService.createVehicle(vehicleData);\n      \n      // Convert MongoDB _id to id for frontend compatibility\n      const mongoVehicle = newVehicle as any;\n      const vehicleWithId = { \n        ...newVehicle, \n        id: mongoVehicle._id || newVehicle.id,\n        // Ensure boolean fields have default values\n        isListed: newVehicle.isListed || false,\n        isAuctioned: newVehicle.isAuctioned || false\n      };\n      \n      dispatch({ type: 'ADD_VEHICLE', payload: vehicleWithId });\n      \n      // Reload user data to ensure everything is in sync\n      if (state.currentUser) {\n        await loadUserData(state.currentUser.id);\n      }\n    } catch (error) {\n      console.error('Error adding vehicle:', error);\n    }\n  };\n\n  const updateVehicle = async (updatedVehicle: Vehicle) => {\n    try {\n      const vehicle = await ApiService.updateVehicle(updatedVehicle.id, updatedVehicle);\n      dispatch({ type: 'UPDATE_VEHICLE', payload: vehicle });\n      \n      // If the vehicle has an active listing, refresh all listings to ensure \n      // the listing shows the updated vehicle images\n      if (vehicle.isListed && vehicle.listingId) {\n        await loadAllListings(true);\n      }\n    } catch (error) {\n      console.error('Error updating vehicle:', error);\n    }\n  };\n\n  const deleteVehicle = async (vehicleId: string) => {\n    try {\n      await ApiService.deleteVehicle(vehicleId);\n      dispatch({ type: 'DELETE_VEHICLE', payload: vehicleId });\n    } catch (error) {\n      console.error('Error deleting vehicle:', error);\n    }\n  };\n\n  const addListing = async (listingData: Omit<Listing, 'id' | 'createdAt' | 'updatedAt' | 'views' | 'lastRenewed' | 'canRenewAfter'>) => {\n    if (!state.currentUser) return;\n\n    try {\n      const newListing = await ApiService.createListing(listingData);\n      // Convert MongoDB _id to id for frontend compatibility\n      const mongoListing = newListing as any;\n      const listingWithId = { ...newListing, id: mongoListing._id || newListing.id };\n      dispatch({ type: 'ADD_LISTING', payload: listingWithId });\n\n      // Update vehicle to mark as listed immediately in local state\n      const vehicle = state.vehicles.find(v => v.id === listingData.vehicleId);\n      if (vehicle) {\n        const updatedVehicle: Vehicle = {\n          ...vehicle,\n          isListed: true,\n          listingId: listingWithId.id,\n          updatedAt: new Date().toISOString(),\n        };\n        // Update local state immediately\n        dispatch({ type: 'UPDATE_VEHICLE', payload: updatedVehicle });\n      }\n\n      // Reload all user data to ensure everything is in sync\n      if (state.currentUser) {\n        await loadUserData(state.currentUser.id);\n      }\n      \n      // Also refresh all listings to ensure new listing appears immediately\n      await loadAllListings(true);\n      \n    } catch (error) {\n      console.error('Error adding listing:', error);\n    }\n  };\n\n  const updateListing = async (updatedListing: Listing) => {\n    try {\n      const listing = await ApiService.updateListing(updatedListing.id, updatedListing);\n      dispatch({ type: 'UPDATE_LISTING', payload: listing });\n      \n      // Reload user data to ensure everything is in sync\n      if (state.currentUser) {\n        await loadUserData(state.currentUser.id);\n      }\n      \n      // Also refresh all listings to ensure price changes are visible immediately\n      await loadAllListings(true);\n    } catch (error) {\n      console.error('Error updating listing:', error);\n    }\n  };\n\n  const deleteListing = async (listingId: string) => {\n    try {\n      await ApiService.deleteListing(listingId);\n      dispatch({ type: 'DELETE_LISTING', payload: listingId });\n\n      // Reload user data to ensure everything is in sync\n      if (state.currentUser) {\n        await loadUserData(state.currentUser.id);\n      }\n    } catch (error) {\n      console.error('Error deleting listing:', error);\n    }\n  };\n\n  const renewListing = async (listingId: string) => {\n    try {\n      const response = await ApiService.renewListing(listingId);\n      const renewedListing = { ...response.listing, id: response.listing.id };\n      dispatch({ type: 'UPDATE_LISTING', payload: renewedListing });\n      \n      // Reload user data to ensure everything is in sync\n      if (state.currentUser) {\n        await loadUserData(state.currentUser.id);\n      }\n      \n      // Also refresh all listings to show updated renewal time\n      await loadAllListings(true);\n    } catch (error) {\n      console.error('Error renewing listing:', error);\n    }\n  };\n\n  const incrementListingViews = async (listingId: string) => {\n    try {\n      // The backend automatically increments views when getting a listing\n      await ApiService.getListing(listingId);\n      \n      // Update local state by incrementing views\n      const listing = state.listings.find(l => l.id === listingId);\n      if (listing) {\n        const updatedListing: Listing = {\n          ...listing,\n          views: listing.views + 1,\n          updatedAt: new Date().toISOString(),\n        };\n        dispatch({ type: 'UPDATE_LISTING', payload: updatedListing });\n      }\n    } catch (error) {\n      console.error('Error incrementing listing views:', error);\n    }\n  };\n\n  const addReview = async (reviewData: Omit<Review, 'id' | 'createdAt'>) => {\n    try {\n      const response = await ApiService.createReview(reviewData);\n      // Reload all data to update ratings\n      await loadAllListings();\n    } catch (error) {\n      console.error('Error adding review:', error);\n    }\n  };\n\n  const getUserProfile = (userId: string): User | null => {\n    // Try direct match first\n    let user = state.users.find(u => u.id === userId);\n    \n    // If not found, try matching with MongoDB ObjectId format\n    if (!user) {\n      user = state.users.find(u => {\n        const uId = (u as any)._id || u.id;\n        return uId === userId;\n      });\n    }\n    \n    return user || null;\n  };\n\n  const sendMessage = async (messageData: Omit<Message, 'id' | 'timestamp' | 'read'>) => {\n    try {\n      const newMessage = await ApiService.sendMessage(messageData);\n      \n      // Immediately add the message to state\n      dispatch({ type: 'ADD_MESSAGE', payload: newMessage });\n      \n      // Ensure both sender and receiver users are loaded\n      const userIdsToLoad = [messageData.senderId, messageData.receiverId].filter(id => \n        id && !state.users.find(u => u.id === id)\n      );\n      \n      if (userIdsToLoad.length > 0) {\n        try {\n          const users = await ApiService.getUsersBatch(userIdsToLoad);\n          const usersWithId = users.map((u: any) => ({ \n            ...u, \n            id: u._id || u.id \n          }));\n          \n          // Add new users to existing users\n          const allUsers = [...state.users];\n          usersWithId.forEach(user => {\n            if (!allUsers.find(u => u.id === user.id)) {\n              allUsers.push(user);\n            }\n          });\n          \n          dispatch({ type: 'SET_USERS', payload: allUsers });\n        } catch (error) {\n          console.error('Error loading users for message:', error);\n        }\n      }\n      \n    } catch (error) {\n      console.error('Error sending message:', error);\n    }\n  };\n\n  const markMessagesAsRead = async (conversationId: string) => {\n    if (!state.currentUser) return;\n    \n    try {\n      await ApiService.markMessagesAsRead(conversationId);\n      await loadUserMessages();\n    } catch (error) {\n      console.error('Error marking messages as read:', error);\n    }\n  };\n\n  const loadUserMessages = async () => {\n    try {\n      const messages = await ApiService.getUserMessages();\n      dispatch({ type: 'SET_MESSAGES', payload: messages });\n      \n      // Extract users from populated message objects and collect missing user IDs\n      const userIds = new Set<string>();\n      const usersFromMessages: any[] = [];\n      \n      messages.forEach(message => {\n        // Handle populated sender\n        if (typeof message.senderId === 'object' && message.senderId && (message.senderId as any).id) {\n          const senderUser = { ...(message.senderId as any), id: (message.senderId as any).id };\n          usersFromMessages.push(senderUser);\n          userIds.add(senderUser.id);\n        } else if (typeof message.senderId === 'string') {\n          userIds.add(message.senderId);\n        }\n        \n        // Handle populated receiver\n        if (typeof message.receiverId === 'object' && message.receiverId && (message.receiverId as any).id) {\n          const receiverUser = { ...(message.receiverId as any), id: (message.receiverId as any).id };\n          usersFromMessages.push(receiverUser);\n          userIds.add(receiverUser.id);\n        } else if (typeof message.receiverId === 'string') {\n          userIds.add(message.receiverId);\n        }\n      });\n      \n      console.log('👥 Extracted user IDs from messages:', Array.from(userIds));\n      console.log('👥 Current users in state:', state.users.map(u => ({ id: u.id, username: u.username })));\n      \n      // Load users that aren't already in state\n      const missingUserIds = Array.from(userIds).filter(id => \n        !state.users.find(u => u.id === id)\n      );\n      \n      console.log('❓ Missing user IDs:', missingUserIds);\n      \n      if (missingUserIds.length > 0) {\n        try {\n          console.log('🔍 Loading missing users via batch API...');\n          const users = await ApiService.getUsersBatch(missingUserIds);\n          console.log('✅ Loaded users from batch API:', users.map(u => ({ id: u.id, username: u.username })));\n          \n          // Add new users to existing users\n          const allUsers = [...state.users];\n          users.forEach(user => {\n            if (!allUsers.find(u => u.id === user.id)) {\n              allUsers.push(user);\n            }\n          });\n          \n          console.log('👥 Updated users state:', allUsers.map(u => ({ id: u.id, username: u.username })));\n          dispatch({ type: 'SET_USERS', payload: allUsers });\n        } catch (error) {\n          console.error('❌ Error loading missing users:', error);\n          // Fallback: load all users\n          console.log('🔄 Falling back to loading all users...');\n          await loadAllUsers();\n        }\n      } else {\n        console.log('✅ All required users already in state');\n      }\n      \n    } catch (error) {\n      console.error('❌ Error loading messages:', error);\n    }\n  };\n\n  // Load messages only when messages tab is accessed\n  const loadMessagesOnTabSwitch = async () => {\n    try {\n      console.log('🔄 Loading messages for messages tab...');\n      \n      // Load both messages and conversations\n      const [messages, conversations] = await Promise.all([\n        ApiService.getUserMessages(),\n        ApiService.getConversations()\n      ]);\n      \n      console.log('📨 Loaded messages from API:', {\n        count: messages.length,\n        samples: messages.slice(0, 3).map(m => ({\n          id: m.id,\n          senderId: m.senderId,\n          receiverId: m.receiverId,\n          content: m.content.substring(0, 30)\n        }))\n      });\n      \n      console.log('💬 Loaded conversations from API:', {\n        count: conversations.length,\n        samples: conversations.slice(0, 3).map(c => ({\n          id: c.id,\n          participants: c.participants,\n          lastMessage: c.lastMessage?.content?.substring(0, 30)\n        }))\n      });\n      \n      dispatch({ type: 'SET_MESSAGES', payload: messages });\n      dispatch({ type: 'SET_CONVERSATIONS', payload: conversations });\n      \n      // Extract users from populated message objects and conversations\n      const userIds = new Set<string>();\n      const usersFromMessages: any[] = [];\n      \n      messages.forEach(message => {\n        // Handle populated sender\n        if (typeof message.senderId === 'object' && message.senderId && (message.senderId as any).id) {\n          const senderUser = { ...(message.senderId as any), id: (message.senderId as any).id };\n          usersFromMessages.push(senderUser);\n          userIds.add(senderUser.id);\n        } else if (typeof message.senderId === 'string') {\n          userIds.add(message.senderId);\n        }\n        \n        // Handle populated receiver\n        if (typeof message.receiverId === 'object' && message.receiverId && (message.receiverId as any).id) {\n          const receiverUser = { ...(message.receiverId as any), id: (message.receiverId as any).id };\n          usersFromMessages.push(receiverUser);\n          userIds.add(receiverUser.id);\n        } else if (typeof message.receiverId === 'string') {\n          userIds.add(message.receiverId);\n        }\n      });\n      \n      // Extract users from conversations\n      conversations.forEach(conversation => {\n        // Add otherUser from conversation\n        if ((conversation as any).otherUser) {\n          const otherUser = { ...(conversation as any).otherUser };\n          usersFromMessages.push(otherUser);\n          userIds.add(otherUser.id);\n        }\n        \n        // Also add participant IDs in case they're not populated\n        if (conversation.participants) {\n          conversation.participants.forEach(participantId => {\n            if (typeof participantId === 'string') {\n              userIds.add(participantId);\n            }\n          });\n        }\n      });\n      \n      console.log('👥 Extracted user IDs from messages and conversations:', Array.from(userIds));\n      console.log('👥 Users from populated messages and conversations:', usersFromMessages.map(u => ({ id: u.id, username: u.username })));\n      console.log('👥 Current users in state:', state.users.map(u => ({ id: u.id, username: u.username })));\n      \n      // Add populated users to state first\n      let allUsers = [...state.users];\n      usersFromMessages.forEach(user => {\n        if (!allUsers.find(u => u.id === user.id)) {\n          allUsers.push(user);\n        }\n      });\n      \n      // Find users that still need to be fetched (not populated and not in state)\n      const missingUserIds = Array.from(userIds).filter(id => \n        !allUsers.find(u => u.id === id)\n      );\n      \n      console.log('❓ Missing user IDs after adding populated users:', missingUserIds);\n      \n      if (missingUserIds.length > 0) {\n        try {\n          console.log('🔍 Loading missing users via batch API...');\n          const users = await ApiService.getUsersBatch(missingUserIds);\n          console.log('✅ Loaded users from batch API:', users.map(u => ({ id: u.id, username: u.username })));\n          \n          // Add fetched users to existing users\n          users.forEach(user => {\n            if (!allUsers.find(u => u.id === user.id)) {\n              allUsers.push(user);\n            }\n          });\n        } catch (error) {\n          console.error('❌ Error loading missing users:', error);\n          // Fallback: load all users\n          console.log('🔄 Falling back to loading all users...');\n          await loadAllUsers();\n          return; // Exit early since loadAllUsers will update state\n        }\n      }\n      \n      console.log('👥 Final updated users state:', allUsers.map(u => ({ id: u.id, username: u.username })));\n      dispatch({ type: 'SET_USERS', payload: allUsers });\n      \n    } catch (error) {\n      console.error('❌ Error loading messages:', error);\n    }\n  };\n\n  const addTrade = async (tradeData: Omit<Trade, 'id' | 'createdAt' | 'updatedAt'>) => {\n    try {\n      const newTrade = await ApiService.createTrade(tradeData);\n      \n      // Convert MongoDB _id to id for frontend compatibility\n      const mongoTrade = newTrade as any;\n      const tradeWithId = { ...newTrade, id: mongoTrade._id || newTrade.id };\n      \n      dispatch({ type: 'ADD_TRADE', payload: tradeWithId });\n    } catch (error) {\n      console.error('❌ Error adding trade:', error);\n      throw error; // Re-throw so the calling component can handle it\n    }\n  };\n\n  const updateTrade = async (tradeOrId: Trade | string, tradeData?: Partial<Trade>) => {\n    try {\n      let tradeId: string;\n      let updatedTradeData: Partial<Trade>;\n      \n      // Handle both old format (full trade object) and new format (id + data)\n      if (typeof tradeOrId === 'string') {\n        tradeId = tradeOrId;\n        updatedTradeData = tradeData!;\n      } else {\n        tradeId = tradeOrId.id;\n        updatedTradeData = tradeOrId;\n      }\n      \n      // If trade is being cancelled, it gets deleted on the backend\n      if (updatedTradeData.status === 'cancelled') {\n        const result = await ApiService.updateTrade(tradeId, updatedTradeData);\n        // Remove the cancelled trade from state since backend deletes it\n        dispatch({ type: 'SET_TRADES', payload: state.trades.filter(t => t.id !== tradeId) });\n        console.log('✅ Cancelled trade removed from state');\n      } else {\n        const trade = await ApiService.updateTrade(tradeId, updatedTradeData);\n        dispatch({ type: 'UPDATE_TRADE', payload: trade });\n        \n        // If trade is completed, reload listings to remove sold listing\n        if (updatedTradeData.status === 'completed') {\n          console.log('🔄 Trade completed, reloading listings to update sold status');\n          await loadAllListings(true); // Force refresh\n        }\n      }\n    } catch (error) {\n      console.error('Error updating trade:', error);\n      throw error; // Re-throw so the calling component can handle it\n    }\n  };\n\n  const deleteTrade = async (tradeId: string) => {\n    try {\n      await ApiService.deleteTrade(tradeId);\n      // Remove the deleted trade from state\n      dispatch({ type: 'SET_TRADES', payload: state.trades.filter(t => t.id !== tradeId) });\n      console.log('✅ Deleted trade removed from state');\n    } catch (error) {\n      console.error('Error deleting trade:', error);\n      throw error; // Re-throw so the calling component can handle it\n    }\n  };\n\n  const cleanupCorruptedTrades = async () => {\n    try {\n      const result = await ApiService.cleanupCorruptedTrades();\n      console.log('Cleanup result:', result);\n      \n      // Reload trades to reflect the cleanup\n      if (state.currentUser) {\n        await loadUserData(state.currentUser.id);\n      }\n      \n      return result;\n    } catch (error) {\n      console.error('Error cleaning up corrupted trades:', error);\n      throw error;\n    }\n  };\n\n  const cleanupVehicleFlags = async () => {\n    try {\n      const result = await ApiService.cleanupVehicleFlags();\n      console.log('Vehicle cleanup result:', result);\n      \n      // Reload user data to reflect the cleanup\n      if (state.currentUser) {\n        await loadUserData(state.currentUser.id);\n      }\n      \n      return result;\n    } catch (error) {\n      console.error('Error cleaning up vehicle flags:', error);\n      throw error;\n    }\n  };\n\n  // Memoize the context value to prevent unnecessary re-renders\n  const contextValue = useMemo(() => ({\n    state,\n    dispatch,\n    login,\n    register,\n    logout,\n    updateUser,\n    addVehicle,\n    updateVehicle,\n    deleteVehicle,\n    getUserVehicles: async (userId: string) => {\n      try {\n        const vehicles = await ApiService.getVehiclesByUserId(userId);\n        return vehicles;\n      } catch (error) {\n        console.error('Error getting user vehicles:', error);\n        return [];\n      }\n    },\n    getVehiclesCount: async () => {\n      try {\n        const result = await ApiService.getUserVehiclesCount();\n        return result.count;\n      } catch (error) {\n        console.error('Error getting vehicles count:', error);\n        return 0;\n      }\n    },\n    addListing,\n    updateListing,\n    deleteListing,\n    renewListing,\n    incrementListingViews,\n    loadAllListings,\n    getListingsCount: async () => {\n      try {\n        const result = await ApiService.getAllListingsCount();\n        return result.count;\n      } catch (error) {\n        console.error('Error getting listings count:', error);\n        return 0;\n      }\n    },\n    addReview,\n    getUserProfile,\n    sendMessage,\n    markMessagesAsRead,\n    addTrade,\n    updateTrade,\n    deleteTrade,\n    cleanupCorruptedTrades,\n    cleanupVehicleFlags,\n    activeTab,\n    setActiveTab,\n    reloadTrades,\n    loadUserMessages,\n    loadMessagesOnTabSwitch,\n  }), [state, dispatch, login, logout, updateUser, addVehicle, updateVehicle, deleteVehicle, addListing, updateListing, deleteListing, renewListing, incrementListingViews, loadAllListings, addReview, getUserProfile, sendMessage, markMessagesAsRead, addTrade, updateTrade, deleteTrade, cleanupCorruptedTrades, cleanupVehicleFlags, activeTab, setActiveTab, reloadTrades, loadUserMessages, loadMessagesOnTabSwitch]);\n\n  return <AppContext.Provider value={contextValue}>{children}</AppContext.Provider>;\n}\n\nexport function useApp() {\n  const context = useContext(AppContext);\n  if (context === undefined) {\n    throw new Error('useApp must be used within an AppProvider');\n  }\n  return context;\n} "],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}